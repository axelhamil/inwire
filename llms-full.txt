# inwire — Complete API Reference

> Type-safe dependency injection for TypeScript. Builder pattern, full inference, no decorators, no tokens.
> Proxy-based lazy singleton resolution. ~4KB gzipped, 0 runtime deps. Clean Architecture internals.

Install: `npm i inwire`
License: MIT
Exports: ESM with full .d.mts

## How It Works

The container is a Proxy. Dependencies are defined via a fluent builder: `container().add('key', factory).build()`. Each `.add()` call accumulates the TypeScript type incrementally — the `c` parameter in every factory is typed as the union of all previously registered dependencies.

When you access a property on the built container, the Proxy intercepts it and delegates to the Resolver. The Resolver orchestrates three injected collaborators:

1. **CycleDetector** — checks if this key is already mid-resolution (circular dependency guard)
2. **DependencyTracker** — creates a tracking Proxy that records which other deps the factory accesses (auto-builds the dependency graph)
3. **Resolver core** — manages the singleton cache and parent chain (for scoped containers)

Resolution flow:
1. Check the singleton cache — if already resolved, return the cached instance
2. Ask CycleDetector if this key is already being resolved — if so, throw `CircularDependencyError`
3. Enter the key in CycleDetector, get a tracking Proxy from DependencyTracker
4. Call the factory function with the tracking proxy
5. Record the discovered dependencies in the graph
6. Cache the result (unless marked transient)
7. Call `onInit()` if the instance implements it (fire-and-forget during lazy access, properly awaited during `preload()`)
8. Leave the key in CycleDetector (via try/finally)

The architecture follows Clean Architecture with three layers:
- **domain/** — Pure contracts (`IResolver`, `ICycleDetector`, `IDependencyTracker`), error types, lifecycle interfaces. Zero external imports.
- **infrastructure/** — `Resolver`, `CycleDetector`, `DependencyTracker`, `transient()`. Depends only on domain/.
- **application/** — `ContainerBuilder`, `container-proxy`, `Preloader` (topological sort + parallel onInit), `Disposer` (reverse-order onDestroy), `Introspection`. Depends on domain/ interfaces.

## container()

```typescript
function container<T extends Record<string, unknown> = Record<string, unknown>>(): ContainerBuilder<T>
```

Creates a new `ContainerBuilder`. Two modes depending on the generic parameter:

### Free Mode (default)

```typescript
import { container } from 'inwire';

const app = container()
  .add('logger', () => new LoggerService())
  .add('db', (c) => new Database(c.logger))      // c: { logger: LoggerService }
  .add('userService', (c) => new UserService(c.db, c.logger))
  .build();

app.userService; // lazy, singleton, fully typed
```

Each `.add()` accumulates the type — `c` in every factory knows about all previously registered dependencies.

### Contract Mode (interface-first)

Pass an interface to constrain keys and return types at compile time:

```typescript
interface AppDeps {
  ILogger: Logger;
  IDatabase: Database;
  IUserService: UserService;
}

const app = container<AppDeps>()
  .add('ILogger', () => new ConsoleLogger())           // key: autocomplete keyof AppDeps
  .add('IDatabase', (c) => new PgDatabase(c.ILogger))  // return must be assignable to Database
  .add('IUserService', (c) => new UserService(c.IDatabase, c.ILogger))
  .build();

app.ILogger; // typed as Logger (not ConsoleLogger)
```

The string key acts as a token (like NestJS), but type-safe at compile time. Use this for dependency inversion — program against interfaces, not implementations.

### Instance Values (eager)

Non-function values are registered eagerly:

```typescript
const app = container()
  .add('config', { port: 3000, host: 'localhost' })  // object, not factory — eager
  .add('db', (c) => new Database(c.config))           // factory — lazy
  .build();
```

Convention: `typeof value === 'function'` → factory (lazy). Otherwise → instance (eager, wrapped in `() => value`).
To register a function as a value: `.add('fn', () => myFunction)`.

## ContainerBuilder Methods

### .add(key, factoryOrInstance)

```typescript
add<K, V>(key: K, factoryOrInstance: ((c: TBuilt) => V) | V): ContainerBuilder<TContract, TBuilt & Record<K, V>>
```

Registers a dependency. If `factoryOrInstance` is a function, it's treated as a lazy factory. Otherwise, it's wrapped as `() => value` (eager instance). Returns a new builder with the accumulated type.

Validation at runtime:
- Reserved keys (`scope`, `extend`, `module`, `preload`, `reset`, `inspect`, `describe`, `health`, `dispose`, `toString`) throw `ReservedKeyError`

### .addTransient(key, factory)

```typescript
addTransient<K, V>(key: K, factory: (c: TBuilt) => V): ContainerBuilder<TContract, TBuilt & Record<K, V>>
```

Registers a transient dependency — a new instance is created on every property access, bypassing the singleton cache.

```typescript
const app = container()
  .add('logger', () => new LoggerService())
  .addTransient('requestId', () => crypto.randomUUID())
  .build();

app.logger === app.logger;         // true  — singleton
app.requestId === app.requestId;   // false — new every time
```

### .addModule(fn)

```typescript
addModule<TNew extends Record<string, unknown>>(
  module: (builder: ContainerBuilder<TContract, TBuilt>) => ContainerBuilder<TContract, TNew>,
): ContainerBuilder<TContract, TNew>
```

Applies a module — a function that chains `.add()` calls on the builder. `c` in the module's factories is fully typed with all previously registered deps.

```typescript
import { container, ContainerBuilder } from 'inwire';

function dbModule<T extends { config: { dbUrl: string } }>(
  b: ContainerBuilder<Record<string, unknown>, T>,
) {
  return b
    .add('db', (c) => new Database(c.config.dbUrl))
    .add('cache', (c) => new Redis(c.config.dbUrl));
}

const app = container()
  .add('config', { dbUrl: 'postgres://...' })
  .addModule(dbModule)
  .build();
```

### .build()

```typescript
build(): Container<TBuilt>
```

Builds and returns the container. Creates the Resolver (with injected CycleDetector and DependencyTracker) and the Proxy.

## transient(factory)

```typescript
function transient<T>(factory: (container: unknown) => T): (container: unknown) => T
```

Marks a factory as transient for use with `scope()` and `extend()`. Internally stamps the function with `Symbol.for('inwire:transient')` — the Resolver checks this marker to skip caching.

```typescript
import { container, transient } from 'inwire';

const app = container()
  .add('logger', () => new LoggerService())
  .build();

const extended = app.extend({
  requestId: transient(() => crypto.randomUUID()),
});

extended.requestId === extended.requestId; // false — new every time
```

Use `addTransient()` on the builder for transient deps at build time. Use `transient()` wrapper for scope/extend.

## container.scope(extra, options?)

```typescript
scope<E extends Record<string, (c: T) => unknown>>(
  extra: E,
  options?: ScopeOptions,
): Container<T & { [K in keyof E]: ReturnType<E[K]> }>
```

Creates a child container with additional dependencies. The child inherits all parent singletons via a parent Resolver chain. Scoped singletons are independent — they are cached in the child's own cache.

The `c` parameter in scope factories is typed as the parent container type `T`.

```typescript
const app = container()
  .add('logger', () => new LoggerService())
  .add('db', () => new Database())
  .build();

const request = app.scope({
  requestId: () => crypto.randomUUID(),
  handler: (c) => new Handler(c.logger),  // c typed as typeof app
});

request.requestId;  // scoped singleton (unique to this child)
request.logger;     // inherited from parent (same instance)
```

Use `scope()` for request-level isolation where child deps should not pollute the parent.

### Named Scopes

Pass `{ name }` for debugging and introspection:

```typescript
const request = app.scope(
  { requestId: () => crypto.randomUUID() },
  { name: 'request-123' },
);

String(request);        // "Scope(request-123) { requestId (pending) }"
request.inspect().name; // "request-123"
```

### Scope Override

Scope can override parent keys, replacing the type:

```typescript
const parent = container()
  .add('value', () => 'hello')
  .build();

const child = parent.scope({
  value: () => 42,  // overrides parent — child.value is number, not string
});
```

## container.extend(extra)

```typescript
extend<E extends Record<string, (c: T) => unknown>>(
  extra: E,
): Container<T & { [K in keyof E]: ReturnType<E[K]> }>
```

Returns a new container with additional dependencies. Unlike `scope()`, the existing singleton cache is **shared** (copied) — already-resolved singletons from the original container are available without re-resolution.

The `c` parameter in extend factories is typed as the parent container type `T`.

```typescript
const base = container()
  .add('logger', () => new LoggerService())
  .build();

const extended = base.extend({
  db: (c) => new Database(c.logger),  // c typed as typeof base
});

extended.logger; // shared singleton from base
extended.db;     // new dependency
```

**scope vs extend**: `scope()` creates a parent-child chain (child delegates to parent for unknown keys). `extend()` creates a flat merged container with a shared cache snapshot. Use `scope()` for request isolation, `extend()` for composition.

**GOTCHA**: Because `extend()` shares the cache, singletons resolved in the original container will be the same objects in the extended container. New singletons resolved in the extended container do NOT propagate back to the original.

## container.module(fn)

```typescript
module<TNew extends Record<string, unknown>>(
  fn: (builder: ContainerBuilder<Record<string, unknown>, T>) => ContainerBuilder<Record<string, unknown>, TNew>,
): Container<TNew>
```

Applies a module post-build using the builder pattern for incremental type accumulation of `c`. Semantically equivalent to `extend()` but uses `ContainerBuilder` so that each `.add()` in the callback types `c` with all previously added deps.

```typescript
const core = container()
  .add('config', { dbUrl: 'postgres://...' })
  .add('logger', () => new Logger())
  .build();

// Post-build module — c is typed incrementally
const withDb = core.module((b) => b
  .add('db', (c) => new Database(c.config.dbUrl))   // c: { config, logger }
  .add('cache', (c) => new Redis(c.config.dbUrl))    // c: { config, logger, db }
);

// Chainable
const full = withDb.module((b) => b
  .add('userService', (c) => new UserService(c.db, c.logger))
);
```

Works on containers produced by `scope()`, `extend()`, and other `module()` calls.

Internally, `module()` creates a fresh `ContainerBuilder`, passes it to `fn`, extracts the factories via `_toRecord()`, and delegates to `extend()`.

## container.preload(...keys)

```typescript
preload(...keys: (keyof T)[]): Promise<void>
```

Eagerly resolves specific dependencies (warm-up). Call with specific keys to resolve only those, or **without arguments to resolve all dependencies**.

```typescript
const app = container()
  .add('db', () => new Database())
  .add('cache', () => new Redis())
  .add('logger', () => new LoggerService())
  .build();

await app.preload('db', 'cache');
// db and cache are now resolved, logger is still lazy

await app.preload();
// resolve ALL dependencies at once
```

Internally, `preload()` delegates to the `Preloader` use case which:
1. Resolves all factories with `onInit()` deferred
2. Builds the full dependency graph via the tracking proxy
3. Computes topological levels using Kahn's BFS algorithm
4. Runs `onInit()` for each level in parallel (`Promise.allSettled`), levels sequentially

If multiple `onInit()` calls throw, errors are collected into an `AggregateError`.

**GOTCHA — CRITICAL**: `preload()` is the **only** way to properly await async `onInit()` hooks. During normal property access, `onInit()` is called but NOT awaited (fire-and-forget, errors stored as `AsyncInitErrorWarning` in `health().warnings`). If your service has async initialization (e.g. database connection), you MUST use `preload()` to surface errors.

## container.reset(...keys)

```typescript
reset(...keys: (keyof T)[]): void
```

Invalidates cached singletons, forcing re-creation on next access. The next property access will re-execute the factory and call `onInit()` again if implemented.

```typescript
app.db;         // creates Database
app.reset('db');
app.db;         // creates a NEW Database instance
```

`reset()` does not affect parent scopes — it only clears the cache of the container it's called on. Resetting an unresolved key is a silent no-op.

## container.inspect()

```typescript
inspect(): ContainerGraph
```

Returns the full dependency graph as a serializable JSON object. Named scopes include a `name` field.

```typescript
interface ContainerGraph {
  name?: string;
  providers: Record<string, ProviderInfo>;
}

interface ProviderInfo {
  key: string;
  resolved: boolean;
  deps: string[];
  scope: 'singleton' | 'transient';
}
```

```typescript
app.inspect();
// {
//   providers: {
//     db: { key: 'db', resolved: true, deps: [], scope: 'singleton' },
//     userRepo: { key: 'userRepo', resolved: true, deps: ['db'], scope: 'singleton' },
//     logger: { key: 'logger', resolved: false, deps: [], scope: 'singleton' }
//   }
// }
```

**AI usage**: Pipe `JSON.stringify(app.inspect(), null, 2)` into an LLM to analyze the architecture, detect issues, or generate documentation from the live dependency graph.

## container.describe(key)

```typescript
describe(key: keyof T | string): ProviderInfo
```

Returns detailed information about a single provider.

```typescript
app.describe('userService');
// { key: 'userService', resolved: true, deps: ['userRepo', 'logger'], scope: 'singleton' }
```

If the key is not registered, returns `{ key, resolved: false, deps: [], scope: 'singleton' }`.

## container.health()

```typescript
health(): ContainerHealth
```

Returns container health status and warnings.

```typescript
interface ContainerHealth {
  totalProviders: number;
  resolved: string[];
  unresolved: string[];
  warnings: ContainerWarning[];
}

interface ContainerWarning {
  type: 'scope_mismatch' | 'async_init_error';
  message: string;
  details: Record<string, unknown>;
}
```

```typescript
app.health();
// {
//   totalProviders: 4,
//   resolved: ['db', 'logger'],
//   unresolved: ['cache', 'userService'],
//   warnings: [
//     { type: 'scope_mismatch', message: "Singleton 'userService' depends on transient 'requestId'.", details: { singleton: 'userService', transient: 'requestId' } }
//   ]
// }
```

## container.dispose()

```typescript
dispose(): Promise<void>
```

Disposes the container. Delegates to the internal `Disposer` which calls `onDestroy()` on all resolved instances that implement it, in **reverse resolution order** (LIFO). Resilient: continues calling other `onDestroy()` handlers even if one throws. Clears the singleton cache, init state, and dependency graph after disposal.

```typescript
app.db;
app.cache;
await app.dispose(); // calls cache.onDestroy() then db.onDestroy()
```

If multiple `onDestroy()` calls throw, all errors are collected into an `AggregateError`. If only one throws, the raw error is rethrown.

**GOTCHA**: After `dispose()`, accessing dependencies will re-resolve them (cache is cleared). This can cause unexpected behavior if you continue using the container after disposal.

## detectDuplicateKeys(...modules)

```typescript
function detectDuplicateKeys(...modules: Record<string, unknown>[]): string[]
```

Pre-spread validation utility. Detects duplicate keys across multiple module objects. Returns an array of keys that appear in more than one module. Duplicate keys are also surfaced internally via `health().warnings` as `duplicate_key` warnings.

```typescript
import { detectDuplicateKeys } from 'inwire';

const authModule = { logger: () => new AuthLogger(), auth: () => new AuthService() };
const userModule = { logger: () => new UserLogger(), user: () => new UserService() };

detectDuplicateKeys(authModule, userModule);
// ['logger'] — appears in both modules
```

## String(container)

Containers implement `toString()` for human-readable output:

```typescript
String(app);
// "Container { db -> [] (resolved), logger (pending) }"
```

Also works with `Symbol.toPrimitive` and `Symbol.toStringTag`.

## Lifecycle Hooks: OnInit / OnDestroy

```typescript
interface OnInit {
  onInit(): void | Promise<void>;
}

interface OnDestroy {
  onDestroy(): void | Promise<void>;
}
```

Lifecycle hooks are **duck-typed** — no need to explicitly implement the interface. Any object with an `onInit` or `onDestroy` method will be detected automatically.

```typescript
import type { OnInit, OnDestroy } from 'inwire';

class Database implements OnInit, OnDestroy {
  async onInit() { await this.connect(); }
  async onDestroy() { await this.disconnect(); }
}

const app = container()
  .add('db', () => new Database())
  .build();

// Use preload to properly await async onInit:
await app.preload('db');

// Later, dispose calls onDestroy in LIFO order:
await app.dispose();
```

**GOTCHA — CRITICAL**: During normal property access (`app.db`), `onInit()` IS called but NOT awaited. It runs as fire-and-forget. If `onInit()` returns a Promise:
- The Promise is caught silently (errors are swallowed)
- The instance is returned immediately, potentially before initialization completes
- Use `await app.preload('db')` to ensure `onInit()` completes and errors surface

This is by design: property access in JavaScript is synchronous, so the Proxy cannot await.

## Test Overrides Pattern

Build a separate container with mocks — no special test API needed:

```typescript
function createTestContainer() {
  return container()
    .add('logger', () => ({ log: () => {} }))       // silent mock
    .add('db', () => new InMemoryDatabase())         // mock
    .add('userService', (c) => new UserService(c.db, c.logger))
    .build();
}

const test = createTestContainer();
test.userService; // uses mocked deps
```

## Type Utilities

```typescript
type Container<T extends Record<string, unknown> = Record<string, unknown>> = T & IContainer<T>;
interface ScopeOptions { name?: string }
```

Internal types (not exported from barrel):
```typescript
type Factory<T = unknown> = (container: unknown) => T;
type DepsDefinition = Record<string, Factory>;
type ResolvedDeps<T extends DepsDefinition> = { readonly [K in keyof T]: ReturnType<T[K]> };
```

## Error Reference

All errors extend `ContainerError`, which extends `Error`. Every error has:
- `hint: string` — actionable fix suggestion
- `details: Record<string, unknown>` — structured context for programmatic consumption

### ContainerConfigError

Thrown when a non-function value is passed in scope/extend deps definition.

```
'apiKey' must be a factory function, got string.
hint: "Wrap it: apiKey: () => 'sk-123'"
```

Constructor: `new ContainerConfigError(key: string, actualType: string)`
Details: `{ key, actualType }`

Note: In the builder, non-function values passed to `.add()` are automatically treated as instance values (wrapped in `() => value`). This error only applies to `scope()` and `extend()`.

### ReservedKeyError

Thrown when a reserved container method name is used as a dependency key. Reserved keys: `scope`, `extend`, `preload`, `reset`, `inspect`, `describe`, `health`, `dispose`, `toString`.

```
'inspect' is a reserved container method.
hint: "Rename this dependency, e.g. 'inspectService' or 'myInspect'."
```

Constructor: `new ReservedKeyError(key: string, reserved: readonly string[])`
Details: `{ key, reserved }`

### ProviderNotFoundError

Thrown when a dependency cannot be found during resolution. Includes Levenshtein-based fuzzy suggestion if a similar key exists (>= 50% similarity).

```
Cannot resolve 'userServce': dependency 'userServce' not found.
Registered keys: [userService, logger, db]
Did you mean 'userService'?
hint: "Did you mean 'userService'? Or add 'userServce' to your container: ..."
```

Constructor: `new ProviderNotFoundError(key: string, chain: string[], registered: string[], suggestion?: string)`
Details: `{ key, chain, registered, suggestion }`

### CircularDependencyError

Thrown when a circular dependency is detected in the resolution chain.

```
Circular dependency detected while resolving 'authService'.
Cycle: authService -> userService -> authService
```

Constructor: `new CircularDependencyError(key: string, chain: string[])`
Details: `{ key, chain, cycle }`

### UndefinedReturnError

Thrown when a factory function returns `undefined`.

```
Factory 'db' returned undefined.
hint: "Your factory function returned undefined. Did you forget a return statement?"
```

Constructor: `new UndefinedReturnError(key: string, chain: string[])`
Details: `{ key, chain }`

### FactoryError

Thrown when a factory function throws an error during resolution. Wraps the original error.

```
Factory 'db' threw an error: "Connection refused"
hint: "Check the factory function for 'db'. The error occurred during instantiation."
```

Constructor: `new FactoryError(key: string, chain: string[], originalError: unknown)`
Details: `{ key, chain, originalError }` (originalError is the message string)
Additional property: `originalError: unknown` (the raw error object)

### ScopeMismatchWarning

Not an error — a warning emitted when a singleton depends on a transient. Surfaced via `container.health().warnings`.

```
Singleton 'userService' depends on transient 'requestId'.
hint: "The transient value was resolved once and is now frozen inside the singleton. ..."
```

Constructor: `new ScopeMismatchWarning(singletonKey: string, transientKey: string)`
Properties: `type: 'scope_mismatch'`, `message`, `hint`, `details: { singleton, transient }`

### AsyncInitErrorWarning

Not an error — a warning emitted when an async `onInit()` rejects during lazy resolution (fire-and-forget). Surfaced via `container.health().warnings`. Use `preload()` to await and surface these errors properly.

```
onInit() for 'db' rejected: connection refused
hint: "Use preload('db') to await and handle async init errors."
```

Constructor: `new AsyncInitErrorWarning(key: string, error: unknown)`
Properties: `type: 'async_init_error'`, `message`, `hint`, `details: { key, error }`

## Gotchas and Common Pitfalls

1. **Async onInit is fire-and-forget**: `onInit()` is called during property access but NOT awaited. Errors are swallowed. Use `await app.preload('key')` to properly await async initialization.

2. **Scope mismatch**: A singleton depending on a transient freezes the transient value. The singleton will always see the first resolved value. Check `app.health().warnings` for `scope_mismatch` warnings.

3. **Reserved keys**: `scope`, `extend`, `module`, `preload`, `reset`, `inspect`, `describe`, `health`, `dispose`, `toString` cannot be used as dependency keys. Using them throws `ReservedKeyError`.

4. **Undefined return**: Factories that return `undefined` (missing return statement, void function) throw `UndefinedReturnError`. Every factory must return a value.

5. **LIFO dispose order**: `dispose()` calls `onDestroy()` in reverse resolution order. If `db` was resolved before `cache`, `cache.onDestroy()` runs first.

6. **extend() shares cache**: `extend()` copies the singleton cache. Already-resolved singletons are shared. New resolutions in the extended container do NOT propagate back to the original.

7. **scope() vs extend()**: `scope()` creates a parent-child chain (child delegates unknown keys to parent). `extend()` creates a flat merged container. Use `scope()` for request-level isolation, `extend()` for additive composition.

8. **reset() is scope-local**: `reset()` only clears the cache of the container it's called on. In a scope, resetting a key does not affect the parent container's cache.

9. **Instance values in builder only**: `.add('key', plainObject)` auto-wraps as eager instance only on the builder. `scope()` and `extend()` require factory functions — passing non-functions throws `ContainerConfigError`.
